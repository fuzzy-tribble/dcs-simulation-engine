name: Teamwork
version: 1.0.0
description: |
  A game where a player character (PC) and non-player character (NPC) collaborate to achieve a shared goal (optionally over multiple sessions). It is useful to measure how well characters with divergent abilities work together toward a shared objective.
access_settings:
  user:
    valid:
      players: {}  # open to any players
data_collection_settings:
  save_runs: false
character_settings:
  # A wide range of PC and NPC characters are allowed. PC can be any character with human-like-cognition and NPC can be any other character.
  pc:
    valid:
      characters: { "where": { "common_descriptors": { "$regex": "human-?like-cognition", "$options": "i" } } }
      # characters: { 'where': { hid: 'human-normative' } } # allow only normative human PC
  npc:
    valid:
      characters: {} # allow any NPC character
stopping_conditions:
  runtime_seconds: [">=600"] # stop after 10 minutes
  turns: [">=50"]    # stop after 50 total turns
subgraph_customizations:
  additional_updater_rules: |
    - Collaborative Interaction: Both the user and simulator characters actions should working together to achieve a shared goal. The opening scene should setup a scene where both characters have a reason to collaborate based on their descriptions and abilities and possible goals.
graph_config:
  # Optional metadata
  name: explore-game-graph
  description: A game flow graph that sets up and continues a scene including abilities checkpoints for character actions.
  # Custom state field values that can be (used in nodes and edges)
  # TODO: add context_overrides to override context values per game if needed
  # context_overrides:
  #   retry_limits:
  #     user: 2
  #     simulator: 2
  state_overrides:
    retry_limits: 
      user: 2
      ai: 2
  ### Graph Nodes ###
  # If kind is "builtin.<name>" then it takes config according to that builtin function definition.
  # If kind is "custom" then it takes provider, model, and system_template that invokes a model and returns a dict/object according to "Output format" in the system_template.
  nodes:
    - name: command_filter
      kind: builtin.command_filter # command builtin func takes command to match "eg. help" and a message to display and/or states updates. It checks for a match in event_draft.content
      kwargs:
        command_handlers:
          help:
            simulator_output:
              type: info
              content: |
                Describe an action...
                - Eg. If your character can see and move you might say "I look around the room and walk to the door."

                Here is are reminder of your character's abilities:
                {{ pc.abilities }}
    - name: enter_message
      kind: builtin.update_state # message builtin func takes a message: str and displays writes it to simulator_output so the user can see it without it being part of the message history.
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              # Welcome
              In this game there is no predefined objective or task. You can just engage freely with the other character. 

              You are playing as: {{ pc.hid }} ({{ pc.short_description }})
              
              The simulator is playing as: {{ npc.hid }} ({{ npc.short_description }})
          lifecycle: UPDATE
    - name: exit_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              Game exited with reason: {{ exit_reason }}
    - name: complete_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              # Game Complete
              The game has completed after {{ len(events) }} total turns.
        message: |
          An unhandled checkpoint condiftion was reached...
          - invalid_reason: {{ invalid_reason }}
          - event_draft: {{ event_draft }}
          - retries: {{ retries }}
          - retry_limits: {{ retry_limits }}
    - name: error_in_lifecycle
      kind: builtin.raise_error # error builtin funct takes a message: str and raises an error with that message.
      kwargs:
        message: |
          An unhandled lifecycle status was reached: {{ lifecycle }}
  edges:
    - from: __START__
      to: 
        conditional:
          # sometimes system writes a message to user
          - if: "state['special_user_message']"
            then: __END__ # end graph so special message is displayed
          # on first turn, show welcome message
          - if: "state['lifecycle'] == 'ENTER'"
            then: enter_message
          # on exit lifecycle, show exit message
          - if: "state['lifecycle'] == 'EXIT'"
            then: exit_message
          - if: "state['lifecycle'] == 'UPDATE' and state['event_draft']['type'] == 'user'"
            then: command_filter
          - if: "state['lifecycle'] == 'UPDATE' and state['event_draft']['type'] == 'ai'"
            then: update
          - else: error_in_lifecycle
    
    # after welcome message, run update node to setup initial scene
    - from: enter_message
      to: update

    # after exit message, end the graph
    - from: exit_message
      to: __END__

    # after users message has gone through command filter, 
    # end if special usermessage else continue lifecycle handling
    - from: command_filter
      to: 
        conditional:
          - if: "state['special_user_message']"
            then: __END__ # end graph so special message is displayed
          - else: checkpoint # send users draft to checkpoint for validation
            
    # after simulator turn, always send to checkpoint for validation
    - from: update
      to: checkpoint 

    - from: checkpoint # validate event_draft (either give invalid_reason or add it to events and continue)
      to:
        conditional:
            # if invalid and retries left
          - if: "state['invalid_reason'] and state['retries'][state['event_draft']['type']] < state['retry_limits'][state['event_draft']['type']]"
            then: retry
          # if user invalid and no retries left
          - if: "state['event_draft']['type'] == 'user' and state['invalid_reason'] and state['retries'][state['event_draft']['type']] >= state['retry_limits'][state['event_draft']['type']]"
            then: user_max_retry_exit
          # if simulator turn invalid and no retries left
          - if: "state['event_draft']['type'] == 'ai' and state['invalid_reason'] and state['retries'][state['event_draft']['type']] >= state['retry_limits'][state['event_draft']['type']]"
            then: simulator_max_retry_exit
          # if valid and simulator turn
          - if: "state['event_draft']['type'] == 'ai'"
            then: __END__ # simulator created a valid message - end turn
          # if valid and user message
          - if: "state['event_draft']['type'] == 'user'"
            then: update  # user created a valid message - continue to simulator turn
          - else: error_in_checkpoint


    - from: user_max_retry_exit
      to: exit_message

    - from: simulator_max_retry_exit
      to: exit_message

    - from: retry
      to:
        conditional:
          - if: "{{ state['event_draft']['type'] == 'user' }}"
            then: __END__
          - if: "{{ state['event_draft']['type'] == 'ai' }}"
            then: update
          - else: error_in_checkpoint
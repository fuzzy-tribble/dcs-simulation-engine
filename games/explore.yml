### METADATA ###
name: Explore
version: 1.0.0
authors: ["DCS"]
description: |
  A lightweight interaction sandbox that allows users/players to freely explore and interact with characters. There are no goals, no data collection, and no extra mechanics. Useful for demos and open-ended play.

### ACCESS SETTINGS ###
# Defines who may access/play using a MongoDB-style query on players.
# Examples:
#   - Anyone may play: {}
#   - Players must have a player_id: { "where": { "player_id": { "$exists": true } } }
#   - Only with consent: { "consent_given": true }
#   - Only with expertise data: { "expertise": { "$exists": true } }
access_settings:
  user:
    valid:
      players: {}  # open to any players

### DATA COLLECTION SETTINGS ###
# Defines what data is collected durring and after game play.
data_collection_settings:
  save_runs: false

### CHARACTER SELECTION SETTINGS ###
# Defines what characters may be used for the user/player character (PC) and non-player character (NPC) using a MongoDB-style query on collections characters, players or runs.
# NOTE: if the interface allows users to select PC and NPC characters thats fine, their selection will just be validated against these criteria. If no selection is provided and the query returns multiple characters one will be selected at random. If one character is returned it will be used.
character_settings:
  # A wide range of PC and NPC characters are allowed. PC can be any character with human-like-cognition and NPC can be any other character.
  pc:
    valid:
      characters: { "where": { "common_descriptors": { "$regex": "human-?like-cognition", "$options": "i" } } }
      # characters: { 'where': { hid: 'human-normative' } } # allow only normative human PC
      # TODO: consier adding allow_player_selection
      # display_choice: "{hid} - {short_description}" # allow player to choose their PC from valid characters
  npc:
    valid:
      characters: {} # allow any NPC character

### ADDITIONAL STOPPING CRITERIA ###
stopping_conditions:
  runtime_seconds: [">=600"] # stop after 10 minutes
  turns: [">=50"]    # stop after 50 total turns

### GAME FLOW/GRAPH SETTINGS ###
# Defines the game lifecycle and objectives, and overall flow using a Langgraph graph of nodes and edges. Nodes are i/o functions. We provide builtins for common functionality (like forms, checkpoints, etc.). 
graph_config:
  # Optional metadata
  name: explore-game-graph
  description: A game flow graph that sets up and continues a scene including abilities checkpoints for character actions.
  # Custom state field values that can be (used in nodes and edges)
  # TODO: add context_overrides to override context values per game if needed
  # context_overrides:
  #   retry_limits:
  #     user: 2
  #     simulator: 2
  state_overrides:
    retry_limits: 
      user: 2
      ai: 2
  ### Graph Nodes ###
  # If kind is "builtin.<name>" then it takes config according to that builtin function definition.
  # If kind is "custom" then it takes provider, model, and system_template that invokes a model and returns a dict/object according to "Output format" in the system_template.
  nodes:
    - name: command_filter
      kind: builtin.command_filter # command builtin func takes command to match "eg. help" and a message to display and/or states updates. It checks for a match in event_draft.content
      kwargs:
        command_handlers:
          help:
            special_user_message:
              type: info
              content: |
                Describe an action...
                - Eg. If your character can see and move you might say "I look around the room and walk to the door."

                Here is are reminder of your character's abilities:
                {{ pc.abilities }}
    - name: enter_message
      kind: builtin.update_state # message builtin func takes a message: str and displays writes it to special_user_message so the user can see it without it being part of the message history.
      kwargs:
        state_updates:
          special_user_message:
            type: info
            content: |
              # Welcome
              In this game there is no predefined objective or task. You can just engage freely with the other character. 

              You are playing as: {{ pc.hid }} ({{ pc.short_description }})
              
              The simulator is playing as: {{ npc.hid }} ({{ npc.short_description }})
          lifecycle: UPDATE
    - name: exit_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          special_user_message:
            type: info
            content: |
              Game exited with reason: {{ exit_reason }}
    - name: complete_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          special_user_message:
            type: info
            content: |
              # Game Complete
              The game has completed after {{ len(events) }} total turns.
    - name: error_in_checkpoint
      kind: builtin.raise_error
      kwargs:
        message: |
          An unhandled checkpoint condiftion was reached...
          - invalid_reason: {{ invalid_reason }}
          - event_draft: {{ event_draft }}
          - retries: {{ retries }}
          - retry_limits: {{ retry_limits }}
    - name: error_in_lifecycle
      kind: builtin.raise_error # error builtin funct takes a message: str and raises an error with that message.
      kwargs:
        message: |
          An unhandled lifecycle status was reached: {{ lifecycle }}
    - name: user_max_retry_exit
      kind: builtin.update_state # update_state builtin func takes state_updates: dict[str, Any] and updates the game state with those values.
      kwargs:
        state_updates:
          lifecycle: EXIT
          exit_reason: "maximum retries exceeded"
    - name: retry
      kind: builtin.retry # retry builtin func takes event_draft, invalid_reason?, increments retries for event_draft.type, gathers a user retry message if type is user, and returns updated message draft with guidance if type is simulator.
      kwargs:
        retry_message: |
          Your previous action was invalid: Please try again.
          Remaining Retries: {{ retry_limits[event_draft.type] - retries[event_draft.type] }}
          Previous Action: {{ event_draft.content }}
          Reason: {{ invalid_reason }}
    - name: simulation_subgraph
      kind: builtin.simulation_subgraph
  ### Graph Edges ###
  # Defines the flow between nodes including conditionals and branching. Conditionals on state variables is used to direct flow to a single output node (no parallization is supported).
  # __START__ and __END__ are special Langgraph nodes that indicate the start and end of the graph.
  edges:
    - from: __START__
      to: 
        conditional:
          # sometimes system writes a message to user
          - if: "state['final_response']"
            then: __END__ # end graph so special message is displayed
          # on first turn, show welcome message
          - if: "state['lifecycle'] == 'ENTER'"
            then: enter_message
          # on exit lifecycle, show exit message
          - if: "state['lifecycle'] == 'EXIT'"
            then: exit_message
          - if: "state['lifecycle'] == 'UPDATE'"
            then: command_filter
          - if: "state['lifecycle'] == 'UPDATE' and state['event_draft']['type'] == 'ai'"
            then: update
          - else: error_in_lifecycle
    
    # after welcome message, run update node to setup initial scene
    - from: enter_message
      to: update

    # after exit message, end the graph
    - from: exit_message
      to: __END__

    # after users message has gone through command filter, 
    # end if special usermessage else continue lifecycle handling
    - from: command_filter
      to: 
        conditional:
          - if: "state['special_user_message']"
            then: __END__ # end graph so special message is displayed
          - else: checkpoint # send users draft to checkpoint for validation
            
    # after simulator turn, always send to checkpoint for validation
    - from: update
      to: checkpoint 

    - from: checkpoint # validate event_draft (either give invalid_reason or add it to events and continue)
      to:
        conditional:
            # if invalid and retries left
          - if: "state['invalid_reason'] and state['retries'][state['event_draft']['type']] < state['retry_limits'][state['event_draft']['type']]"
            then: retry
          # if user invalid and no retries left
          - if: "state['event_draft']['type'] == 'user' and state['invalid_reason'] and state['retries'][state['event_draft']['type']] >= state['retry_limits'][state['event_draft']['type']]"
            then: user_max_retry_exit
          # if simulator turn invalid and no retries left
          - if: "state['event_draft']['type'] == 'ai' and state['invalid_reason'] and state['retries'][state['event_draft']['type']] >= state['retry_limits'][state['event_draft']['type']]"
            then: simulator_max_retry_exit
          # if valid and simulator turn
          - if: "state['event_draft']['type'] == 'ai'"
            then: __END__ # simulator created a valid message - end turn
          # if valid and user message
          - if: "state['event_draft']['type'] == 'user'"
            then: update  # user created a valid message - continue to simulator turn
          - else: error_in_checkpoint


    - from: user_max_retry_exit
      to: exit_message

    - from: simulator_max_retry_exit
      to: exit_message

    - from: retry
      to:
        conditional:
          - if: "{{ state['event_draft']['type'] == 'user' }}"
            then: __END__
          - if: "{{ state['event_draft']['type'] == 'ai' }}"
            then: update
          - else: error_in_checkpoint


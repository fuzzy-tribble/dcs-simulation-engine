### METADATA ###
name: Explore
version: 1.0.0
authors: ["DCS"]
description: |
  A lightweight interaction sandbox that allows users/players to freely explore and interact with characters. There are no goals, no data collection, and no extra mechanics. Useful for demos and open-ended play.

### ACCESS SETTINGS ###
# Defines who may access/play using a MongoDB-style query on players.
# Examples:
#   - Anyone may play: {}
#   - Players must have a player_id: { "where": { "player_id": { "$exists": true } } }
#   - Only with consent: { "consent_given": true }
#   - Only with expertise data: { "expertise": { "$exists": true } }
access_settings:
  user:
    valid:
      players: {}  # open to any players

### DATA COLLECTION SETTINGS ###
# Defines what data is collected durring and after game play.
data_collection_settings:
  save_runs: true

### CHARACTER SELECTION SETTINGS ###
# Defines what characters may be used for the user/player character (PC) and non-player character (NPC) using a MongoDB-style query on collections characters, players or runs.
# NOTE: if the interface allows users to select PC and NPC characters thats fine, their selection will just be validated against these criteria. If no selection is provided and the query returns multiple characters one will be selected at random. If one character is returned it will be used.
character_settings:
  # A wide range of PC and NPC characters are allowed. PC can be any character with human-like-cognition and NPC can be any other character.
  display_pc_choice_as: "{hid} - {short_description}"
  display_npc_choice_as: "{hid} - {short_description}"
  pc:
    valid:
      characters: { "where": { "common_descriptors": { "$regex": "human-?like-cognition", "$options": "i" } } }
      # characters: { 'where': { hid: 'human-normative' } } # allow only normative human PC
  npc:
    valid:
      characters: {} # allow any NPC character

### ADDITIONAL STOPPING CRITERIA ###
stopping_conditions:
  runtime_seconds: [">=600"] # stop after 10 minutes
  turns: [">=50"]    # stop after 50 total turns

### GAME FLOW/GRAPH SETTINGS ###
# Defines the game lifecycle and objectives, and overall flow using a Langgraph graph of nodes and edges. Nodes are i/o functions. We provide builtins for common functionality (like forms, checkpoints, etc.). 
graph_config:
  # Optional metadata
  name: explore-game-graph
  description: A game flow graph that sets up and continues a scene including abilities checkpoints for character actions.
  # Custom state field values that can be (used in nodes and edges)
  state_overrides:
    user_retry_budget: 10
  ### Graph Nodes ###
  # If kind is "builtin.<name>" then it takes config according to that builtin function definition.
  # If kind is "custom" then it takes provider, model, and system_template that invokes a model and returns a dict/object according to "Output format" in the system_template.
  nodes:
    - name: command_filter
      kind: builtin.command_filter # command builtin func takes command to match "eg. help" and a message to display and/or states updates. It checks for a match in event_draft.content
      kwargs:
        command_handlers:
          help:
            simulator_output:
              type: info
              content: |
                Describe an action...
                - Eg. If your character can see and move you might say "I look around the room and walk to the door."

                Here is are reminder of your character's abilities:
                {{ pc.abilities }}
    - name: enter_message
      kind: builtin.update_state # message builtin func takes a message: str and displays writes it to special_user_message so the user can see it without it being part of the message history.
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              Welcome, in this game there is no predefined objective or task. You can just engage freely with the other character.

              You are playing as: {{ pc.hid }} ({{ pc.short_description }})
              
              The simulator is playing as: {{ npc.hid }} ({{ npc.short_description }})
          lifecycle: UPDATE
    - name: exit_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              Game exited with reason: {{ exit_reason }}
    - name: complete_message
      kind: builtin.update_state
      kwargs:
        state_updates:
          simulator_output:
            type: info
            content: |
              # Game Complete
              The game has completed after {{ len(history) }} total turns.
    - name: error_in_lifecycle
      kind: builtin.raise_error # error builtin funct takes a message: str and raises an error with that message.
      kwargs:
        message: |
          An unhandled lifecycle status was reached: {{ lifecycle }}
  ### Graph Edges ###
  # Defines the flow between nodes including conditionals and branching. Conditionals on state variables is used to direct flow to a single output node (no parallization is supported).
  # __START__ and __END__ are special Langgraph nodes that indicate the start and end of the graph.
  edges:
    - from: __START__
      to: 
        conditional:
          - if: "state['simulator_output']"
            then: __END__
          # on first turn, show welcome message
          - if: "state['lifecycle'] == 'ENTER'"
            then: enter_message
          # on exit lifecycle, show exit message
          - if: "state['lifecycle'] == 'EXIT'"
            then: exit_message
          - if: "state['lifecycle'] == 'UPDATE'"
            then: command_filter
          - else: error_in_lifecycle
    
    # after welcome message, run update node to setup initial scene
    - from: enter_message
      to: __SIMULATION_SUBGRAPH__

    # after exit message, end the graph
    - from: exit_message
      to: __END__

    # after users message has gone through command filter, 
    # end if simulator output else continue lifecycle handling
    - from: command_filter
      to: 
        conditional:
          - if: "state['simulator_output']"
            then: __END__
          - else: __SIMULATION_SUBGRAPH__
    
    - from: __SIMULATION_SUBGRAPH__
      to: __END__